import { inject as C, defineComponent as u, provide as P, onUnmounted as j, renderSlot as w, reactive as x, computed as D, toRaw as E, h as I, getCurrentInstance as A, ref as U, toRef as _, openBlock as m, createElementBlock as h, Fragment as g, renderList as $, unref as B, createBlock as b, withCtx as F, resolveDynamicComponent as O, normalizeProps as G, guardReactiveProps as Y } from "vue";
const f = Symbol("ModalStateToken"), R = Symbol("ModalIdToken"), p = () => C(f, {}), z = () => C(R, ""), S = /* @__PURE__ */ u({
  __name: "CreateModal",
  props: {
    modalId: {
      type: String
    }
  },
  setup(l) {
    const s = l, { action: t } = p();
    return P(R, s.modalId), j(() => {
      s.modalId && t?.remove(s.modalId);
    }), (r, e) => w(r.$slots, "default");
  }
});
function k() {
  let l = 0;
  const s = () => `__modal_${l++}`, t = Symbol("ModalId"), e = x({}), a = {};
  return P(f, {
    store: e,
    action: {
      show: (o, n) => {
        n && (e[o].args = {
          ...e[o].args,
          ...n
        }), e[o].visible = !0;
      },
      hide: (o) => {
        e[o].visible = !1;
      },
      remove: (o) => {
        delete e[o], delete a[o];
      },
      getModalId: (o) => (o[t] || (o[t] = s()), o[t]),
      register: (o, n, d) => {
        e[o] ? e[o].args = d : e[o] = {
          comp: n,
          visible: !1,
          args: d
        };
      }
    },
    modalPromise: a
  }), {
    modalList: D(() => Object.keys(e).filter((n) => !!e[n]).filter((n) => e[n]).map((n) => ({
      id: n,
      ...e[n],
      comp: E(e[n].comp)
    })))
  };
}
function H() {
  const {
    modalList: l
  } = k();
  return {
    ModalContent: u({
      name: "ModalContent",
      render() {
        return l.value.map((t) => I(S, {
          modalId: t.id
        }, () => I(t.comp, t.args)));
      }
    })
  };
}
function J(l, s) {
  const r = A().provides[f];
  let e = p();
  r && (e = r);
  const a = e.action?.getModalId(l), c = U(!0), i = e.store?.[a];
  return {
    show: (d) => {
      if ((c.value || !i) && (e.action?.register(a, l, s), c.value = !1), !e.modalPromise[a]) {
        let v, M;
        const L = new Promise((y, T) => {
          v = y, M = T;
        });
        e.modalPromise[a] = {
          promise: L,
          reject: M,
          resolve: v
        };
      }
      return e.action?.show(a, d), e.modalPromise[a].promise;
    },
    hide: () => e.action?.hide(a)
  };
}
function K() {
  const {
    store: l,
    action: s,
    modalPromise: t
  } = p(), r = z(), e = l[r], a = (d) => s?.show(r, d), c = () => s?.hide(r), i = () => s?.remove(r), o = (d) => t[r].resolve(d), n = (d) => t[r].reject(d);
  return {
    show: a,
    hide: c,
    visible: _(e, "visible"),
    args: _(e, "args"),
    remove: i,
    resolve: o,
    reject: n
  };
}
const N = /* @__PURE__ */ u({
  __name: "ModalProvider",
  setup(l) {
    const { modalList: s } = k();
    return (t, r) => (m(), h(g, null, [
      w(t.$slots, "default"),
      (m(!0), h(g, null, $(B(s), (e) => (m(), b(S, {
        key: e.id,
        "modal-id": e.id
      }, {
        default: F(() => [
          (m(), b(O(e.comp), G(Y(e.args)), null, 16))
        ]),
        _: 2
      }, 1032, ["modal-id"]))), 128))
    ], 64));
  }
});
export {
  N as ModalProvider,
  H as createdModalContext,
  J as useModal,
  K as useModalRef
};
